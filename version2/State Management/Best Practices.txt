Best Practices:
✅ Use setState() inside a StatefulWidget.
❌ Don't use it in a StatelessWidget (no state to manage).

✅ Only update state inside the setState() function.
   Why?
   If you modify state outside setState(), Flutter won’t know to rebuild the UI.
❌ Avoid Calling setState() Inside API Calls / Async Functions Directly.

✅ Minimize rebuilds – don't put expensive computations inside setState().
   Why?
   Expensive calculations inside setState() slow down UI updates.

Bad Practice (Heavy Computation Inside setState()):
setState(() {
  _filteredItems = allItems.where((item) => item.startsWith("A")).toList(); // ❌ Slow UI update
});
Good Practice (Compute Before Calling setState()):
final filteredItems = allItems.where((item) => item.startsWith("A")).toList();
setState(() {
  _filteredItems = filteredItems; // ✅ Optimized UI update
});

Use a Single setState() Call for Multiple Updates:
 Why?
 Calling setState() multiple times separately causes unnecessary UI rebuilds.
Instead, batch all updates in a single setState() call to improve performance.

Avoid Side Effects Inside setState()
 Why?
  setState() should only update UI-related state.
  ❌ Don't perform API calls, file handling, or other heavy tasks inside setState().
  ✅ You can trigger these operations before or after calling setState().


