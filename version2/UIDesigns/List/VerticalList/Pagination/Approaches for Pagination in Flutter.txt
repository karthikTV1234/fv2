Manual Pagination Using ListView.builder + ScrollController:
How It Works:
1ï¸. Use ListView.builder to display a scrollable list.
2ï¸. Attach a ScrollController to detect when the user reaches the end.
3ï¸. When the user scrolls to the bottom:
   Call the API to fetch more data.
   Append the new data to the existing list.
   Show a loading indicator at the bottom while fetching data


âœ… Pros:
âœ” Simple, no external packages needed.
âœ” Full control over pagination logic.

âŒ Cons:
âœ– Manual state management required â†’ You need to track isLoading, currentPage, etc.
âœ– Potential for duplicate API calls â†’ If not handled properly, multiple requests may be fired.

ğŸ“Œ State Management Options:
   For small apps â†’ setState() is enough.
   For large apps â†’ Use BLoC to handle state efficiently and separate business logic from UI.

=============================================================

PagedListView (from infinite_scroll_pagination package):
How It Works:
1ï¸. Use PagedListView instead of ListView.builder.
2ï¸. Provide a paging controller (PagingController) to manage loading states.
3ï¸. When the user scrolls to the end:
   The package automatically calls the API for the next page.
   Appends the new data to the existing list.
   Shows a loading indicator while fetching data.
      Handles error states & retries efficiently.

âœ… Pros:
âœ” Prebuilt & optimized for infinite scrolling.
âœ” Automatic state management (loading, error, empty state).
âœ” Avoids duplicate API calls with built-in logic.
âœ” Works well with BLoC, Provider, and Riverpod.

âŒ Cons:
âœ– Third-party dependency â†’ Requires infinite_scroll_pagination package.
âœ– Less manual control â†’ Customizing the pagination logic may be harder.

ğŸ“Œ State Management Options:
For simple use cases â†’ PagingController manages the state automatically.
For large apps â†’ Combine with BLoC to separate API logic from UI.