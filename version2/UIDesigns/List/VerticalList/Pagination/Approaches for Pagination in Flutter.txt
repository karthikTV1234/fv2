Manual Pagination Using ListView.builder + ScrollController:
How It Works:
1️. Use ListView.builder to display a scrollable list.
2️. Attach a ScrollController to detect when the user reaches the end.
3️. When the user scrolls to the bottom:
   Call the API to fetch more data.
   Append the new data to the existing list.
   Show a loading indicator at the bottom while fetching data


✅ Pros:
✔ Simple, no external packages needed.
✔ Full control over pagination logic.

❌ Cons:
✖ Manual state management required → You need to track isLoading, currentPage, etc.
✖ Potential for duplicate API calls → If not handled properly, multiple requests may be fired.

📌 State Management Options:
   For small apps → setState() is enough.
   For large apps → Use BLoC to handle state efficiently and separate business logic from UI.

=============================================================

PagedListView (from infinite_scroll_pagination package):
How It Works:
1️. Use PagedListView instead of ListView.builder.
2️. Provide a paging controller (PagingController) to manage loading states.
3️. When the user scrolls to the end:
   The package automatically calls the API for the next page.
   Appends the new data to the existing list.
   Shows a loading indicator while fetching data.
      Handles error states & retries efficiently.

✅ Pros:
✔ Prebuilt & optimized for infinite scrolling.
✔ Automatic state management (loading, error, empty state).
✔ Avoids duplicate API calls with built-in logic.
✔ Works well with BLoC, Provider, and Riverpod.

❌ Cons:
✖ Third-party dependency → Requires infinite_scroll_pagination package.
✖ Less manual control → Customizing the pagination logic may be harder.

📌 State Management Options:
For simple use cases → PagingController manages the state automatically.
For large apps → Combine with BLoC to separate API logic from UI.